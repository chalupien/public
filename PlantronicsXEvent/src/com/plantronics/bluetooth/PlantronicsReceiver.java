package com.plantronics.bluetooth;

import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static android.bluetooth.BluetoothDevice.*;
import static android.bluetooth.BluetoothHeadset.*;

/**
 * Copyright 2012 Plantronics, Inc.
 * @author  Cary Bran
 *
 * This class extends a broadcast reciever to capture the XEvents
 * generated by the Plantronics headset device.
 *
 * The events are packeged up and send back to the handler
 * within the PlantronicsXEventMessage class.
 */

public class PlantronicsReceiver extends BroadcastReceiver {

   public static final int HEADSET_EVENT = 1;

    private static Map<Integer, String> LANGUAGE_CODE_LOOKUP;

    static {
        Map<Integer, String> t = new HashMap<Integer, String>();
        t.put(1033, "en_US");
        t.put(2057, "en_GB");
        t.put(1041, "ja_JP");
        t.put(1046, "pt_BR");
        t.put(2070, "pt_PT");
        t.put(1036, "fr_FR");
        t.put(2058, "es_MX");
        LANGUAGE_CODE_LOOKUP = Collections.unmodifiableMap(t);
    }

    //BT Profiles
    private static int A2DP = 0x010;
    private static int AVRCP = 0x020;
    private static int HFP = 0x040;
    private static int HSP = 0x080;
    private static int NEO = 0x100;
    private static int CASIRA = 0x200;
    private static int TURBO_BASE = 0x400;
    private static int DONGLE = 0x800;
    private static int PROFILE_ARRAY[] = {A2DP, AVRCP, HFP, HSP, NEO, CASIRA, TURBO_BASE, DONGLE};

    private static Map<Integer, String> PROFILE_LOOKUP;

    static {
        Map<Integer, String> t = new HashMap<Integer, String>();
        t.put(0x010, "A2DP");
        t.put(0x020, "AVRCP");
        t.put(0x040, "HFP");
        t.put(0x080, "HSP");
        t.put(0x100, "NEO");
        t.put(0x200, "CASIRA");
        t.put(0x400, "TURBO_BASE");
        t.put(0x800, "DONGLE");
        PROFILE_LOOKUP = Collections.unmodifiableMap(t);
    }

    //Codecs
    private static Map<Integer, String> CODEC_LOOKUP;

    static {
        Map<Integer, String> t = new HashMap<Integer, String>();
        t.put(1, "CVSD");
        t.put(2, "G.726");
        t.put(3, "G.722");
        t.put(4, "mSBC");
        t.put(5, "A2DP");
        CODEC_LOOKUP = Collections.unmodifiableMap(t);
    }

    //Headset Audio State
    private static Map<Integer, String> AUDIOSTATE_LOOKUP;

    static {
        Map<Integer, String> t = new HashMap<Integer, String>();
        t.put(STATE_AUDIO_CONNECTING, "connecting");
        t.put(STATE_AUDIO_CONNECTED, "connected");
        t.put(STATE_AUDIO_DISCONNECTED, "disconnected");
        AUDIOSTATE_LOOKUP = Collections.unmodifiableMap(t);
    }

    //Button values
    public static final int POWER = 1;
    public static final int HOOK = 2;
    public static final int TALK = 3;
    public static final int VOLUME_UP = 4;
    public static final int VOLUME_DOWN = 5;
    public static final int MUTE = 6;
    public static final int PLAY = 7;
    public static final int PAUSE = 8;
    public static final int FORWARD = 9;
    public static final int REWIND = 10;
    public static final int NEXT = 11;
    public static final int PREVIOUS = 12;
    public static final int STOP = 13;

    private static Map<Integer, String> BUTTON_LOOKUP;

    static {
        Map<Integer, String> t = new HashMap<Integer, String>();
        t.put(POWER, "power");
        t.put(HOOK, "hook");
        t.put(TALK, "talk");
        t.put(VOLUME_UP, "volume up");
        t.put(VOLUME_DOWN, "volume down");
        t.put(MUTE, "mute");
        t.put(PLAY, "play");
        t.put(PAUSE, "pause");
        t.put(FORWARD, "forward");
        t.put(REWIND, "rewind");
        t.put(NEXT, "next");
        t.put(PREVIOUS, "previous");
        t.put(STOP, "stop");
        BUTTON_LOOKUP = Collections.unmodifiableMap(t);
    }


    private static final String TAG = "PlantronicsReceiver";

    private Handler handler;


    /**
     * Constructor requires a handler implementation to
     * send events to
     *
     * @param handler
     */
    public PlantronicsReceiver(Handler handler) {
        this.handler = handler;
    }

    /**
     * Main entry point for the Plantronics headset events.  This method identifies which
     * event has surfaced and send the packaged up result to the handler implementation
     *
     * @param context
     * @param intent
     */
    public void onReceive(Context context, final Intent intent) {

        String action = intent.getAction();

        BluetoothDevice device = intent.getParcelableExtra(EXTRA_DEVICE);
        String bdAddr = device == null ? null : device.getAddress();

        if (ACTION_ACL_CONNECTED.equals(action)) {
            PlantronicsXEventMessage m = new PlantronicsXEventMessage(PlantronicsXEventMessage.HEADSET_CONNECTED_EVENT);
            m.addProperty("bdaddr", bdAddr);
            Message msg = handler.obtainMessage(HEADSET_EVENT, m);
            handler.sendMessage(msg);

        } else if (ACTION_ACL_DISCONNECTED.equals(action)) {
            PlantronicsXEventMessage m = new PlantronicsXEventMessage(PlantronicsXEventMessage.HEADSET_DISCONNECTED_EVENT);
            m.addProperty("bdaddr", bdAddr);
            Message msg = handler.obtainMessage(HEADSET_EVENT, m);
            handler.sendMessage(msg);

        } else if (ACTION_VENDOR_SPECIFIC_HEADSET_EVENT.equals(action)) {
            PlantronicsXEventMessage message = generateMessageFromEvent(intent);
            if (message != null) {
                Message msg = handler.obtainMessage(HEADSET_EVENT, message);
                handler.sendMessage(msg);
            }
        } else if (ACTION_AUDIO_STATE_CHANGED.equals(action)) {
            PlantronicsXEventMessage message = new PlantronicsXEventMessage(PlantronicsXEventMessage.CALL_STATUS_CHANGED_EVENT);
            message.addProperty("currentHeadsetAudioState", AUDIOSTATE_LOOKUP.get(intent.getExtras().getInt(EXTRA_STATE)));
            message.addProperty("previousHeadsetAudioState", AUDIOSTATE_LOOKUP.get(intent.getExtras().getInt(EXTRA_PREVIOUS_STATE)));
            Message msg = handler.obtainMessage(HEADSET_EVENT, message);
            handler.sendMessage(msg);
        } else {
            Log.d(TAG, "Action came in and was not processed: " + action);
        }
    }

    /**
     * Unpackages the raw Plantronics XEvent message into a PlantronicsXEventMessage class
     *
     * @param intent
     * @return
     */
    private PlantronicsXEventMessage generateMessageFromEvent(Intent intent) {
        Bundle eventExtras = intent.getExtras();

        //get the arguments that the headset passed out
        Object[] args = (Object[]) eventExtras.get(EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS);

        String eventName = (String) args[0];
        PlantronicsXEventMessage m = new PlantronicsXEventMessage(eventName);

        Log.d(TAG, "Event from Plantronics headset = " + eventName);

        if (PlantronicsXEventMessage.AUDIO_EVENT.equals(eventName)) {
            Integer audioStatus = (Integer) args[1];

            int micGain = audioStatus % 100;
            m.addProperty("microphoneGain", micGain > 0 ? micGain : "muted");

            int speakerGain = 0;
            if (audioStatus > 100) {
                //handle the case where we have speaker off
                speakerGain = ((audioStatus - micGain) / 100) % 100;
            }
            m.addProperty("speakerGain", speakerGain > 0 ? speakerGain : "muted");

            //only go out and fetch these if they exist - 10000 and above will have these values set
            if (audioStatus >= 10000) {
                int direction = ((audioStatus - ((speakerGain * 100) + micGain)) / 10000) % 10;
                m.addProperty("direction", direction == 0 ? "hostDevice" : "otherDevice");
                int codec = audioStatus / 100000;
                m.addProperty("codec", CODEC_LOOKUP.get(codec));
            }

            return m;

        } else if (PlantronicsXEventMessage.VOCALYST_EVENT.equals(eventName)) {
            m.addProperty("dialString", args[1]);
            return m;
        } else if (PlantronicsXEventMessage.A2DP_EVENT.equals(eventName)) {
            String enabled = ((Integer) args[1]) == 0 ? "off" : "on";
            m.addProperty("A2DP", enabled);
            return m;
        } else if (PlantronicsXEventMessage.SENSOR_STATUS_EVENT.equals(eventName)) {
            //note starting at the offset to get the sensor data is 1
            for (int i = 1; i < args.length; i++) {
                String sensorValPair = (String) args[i];
                //The way these are stored in XEvent format is NAME=VALUE, where name is the sensor name, value is either 0 or 1
                String[] nameVal = sensorValPair.split("=");
                if (nameVal != null && nameVal.length == 2) {
                    m.addProperty(nameVal[0], nameVal[1]);
                }
            }
            return m;
        } else if (PlantronicsXEventMessage.USER_AGENT_EVENT.equals(eventName)) {
            m.addProperty("manufacturerID", args[1]);
            m.addProperty("productID", args[2]);
            m.addProperty("usbPID", args[3]);
            m.addProperty("firmwareID", args[4]);
            m.addProperty("serialNumber", args[5]);
            return m;

        } else if (PlantronicsXEventMessage.LANG_EVENT.equals(eventName)) {
            m.addProperty("language", LANGUAGE_CODE_LOOKUP.get(args[1]));
            return m;

        } else if (PlantronicsXEventMessage.BATTERY_EVENT.equals(eventName)) {
            Integer chargeLevel = (Integer) args[1];
            Integer numberOfLevels = (Integer) args[2];
            Integer minutesOfTalkTime = (Integer) args[3];
            Integer isCharging = (Integer) args[4];

            m.addProperty("level", chargeLevel);
            m.addProperty("charging", isCharging == 1 ? "true" : "false");
            m.addProperty("minutesOfTalkTime", minutesOfTalkTime);
            m.addProperty("numLevels", numberOfLevels);
            return m;

        } else if (PlantronicsXEventMessage.CONNECTED_EVENT.equals(eventName)) {
            for (int i = 1; i < args.length; i++) {
                //looking for name value pairs for the connected device friendly name and the profiles being used
                String deviceName = (String) args[i];
                m.addProperty("connectedDeviceName", deviceName);
                //the device profiles are in the second spot - increment the counter
                i++;
                int profiles = (Integer) args[i];
                int profileCount = 1;
                for (int p : PROFILE_ARRAY) {
                    //bitwise comparison to determine if the profile is supported
                    if ((p & profiles) != 0) {
                        m.addProperty("deviceProfile-" + profileCount, PROFILE_LOOKUP.get(p));
                    }
                }

            }
            return m;
        } else if (PlantronicsXEventMessage.BUTTON_EVENT.equals(eventName)) {
            Integer buttonId = (Integer) args[1];
            Integer pressType = (Integer) args[2];
            m.addProperty("buttonId", buttonId);
            m.addProperty("buttonName", BUTTON_LOOKUP.get(buttonId));
            m.addProperty("pressType", pressType);

            return m;
        } else if (PlantronicsXEventMessage.DON_EVENT.equals(eventName)) {
            return m;
        } else if (PlantronicsXEventMessage.DOFF_EVENT.equals(eventName)) {
            return m;
        }

        Log.e(TAG, "Unknown event " + eventName);
        return null;
    }
}
